
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Concurrency Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        <meta name="author" content="Shubo Zhang">
        
        
    
    <link rel="stylesheet" href="../../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-advanced-emoji/emoji-website.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-chapter-fold/chapter-fold.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-back-to-top-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="chapter09_jdbc.html" />
    
    
    <link rel="prev" href="chapter07_io.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../../">
            
                <a href="../../">
            
                    
                    Overview
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Java Quick Review</li>
        
        
    
        <li class="chapter " data-level="2.1" data-path="../intro.html">
            
                <a href="../intro.html">
            
                    
                    Introduction
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="2.1.1" data-path="chapter01_syntax.html">
            
                <a href="chapter01_syntax.html">
            
                    
                    Syntax
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.2" data-path="chapter02_oo_concepts.html">
            
                <a href="chapter02_oo_concepts.html">
            
                    
                    OO Concepts
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.3" data-path="chapter03_exception.html">
            
                <a href="chapter03_exception.html">
            
                    
                    Exception
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.4" data-path="chapter04_collections.html">
            
                <a href="chapter04_collections.html">
            
                    
                    Collections
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.5" data-path="chapter05_generics.html">
            
                <a href="chapter05_generics.html">
            
                    
                    Generics
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.6" data-path="chapter06_reflection.html">
            
                <a href="chapter06_reflection.html">
            
                    
                    Reflection
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.7" data-path="chapter07_io.html">
            
                <a href="chapter07_io.html">
            
                    
                    IO
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="2.1.8" data-path="chapter08_concurrency.html">
            
                <a href="chapter08_concurrency.html">
            
                    
                    Concurrency
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.9" data-path="chapter09_jdbc.html">
            
                <a href="chapter09_jdbc.html">
            
                    
                    JDBC
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.10" data-path="chapter10_lambda-expressions.html">
            
                <a href="chapter10_lambda-expressions.html">
            
                    
                    Lambda
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.11" data-path="chapter11_aggregate-operations.html">
            
                <a href="chapter11_aggregate-operations.html">
            
                    
                    Aggregate Operation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.12" data-path="appendix-i_HashMap.html">
            
                <a href="appendix-i_HashMap.html">
            
                    
                    Appendix-HashMap
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.13" data-path="appendix-ii_HashMap_ConcurrentHashMap.html">
            
                <a href="appendix-ii_HashMap_ConcurrentHashMap.html">
            
                    
                    Appendix-ConcurrentHashMap
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.14" data-path="unit-testing.html">
            
                <a href="unit-testing.html">
            
                    
                    Unit Testing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.15" data-path="best_practices_in_implementation.html">
            
                <a href="best_practices_in_implementation.html">
            
                    
                    Best Practices
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.16" data-path="interview_questions.html">
            
                <a href="interview_questions.html">
            
                    
                    Interview Questions
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.17" data-path="code_style.html">
            
                <a href="code_style.html">
            
                    
                    Code Style
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.18" data-path="code_tips.html">
            
                <a href="code_tips.html">
            
                    
                    Code Tips
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="header">Notes</li>
        
        
    
        <li class="chapter " data-level="3.1" data-path="../../notes/notes.html">
            
                <a href="../../notes/notes.html">
            
                    
                    Introduction
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="3.1.1" data-path="../../notes/files/git-commands.html">
            
                <a href="../../notes/files/git-commands.html">
            
                    
                    git commands
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.2" data-path="../../notes/files/git-quick-training.html">
            
                <a href="../../notes/files/git-quick-training.html">
            
                    
                    git quick training
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.3" data-path="../../notes/files/cmd-commands.html">
            
                <a href="../../notes/files/cmd-commands.html">
            
                    
                    cmd commands
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.4" data-path="../../notes/files/aws-big-data-exam.html">
            
                <a href="../../notes/files/aws-big-data-exam.html">
            
                    
                    AWS Big Data Exam Note
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="../.." >Concurrency</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
                                <section class="normal markdown-section">
                                
                                <p>#
Chapter VIII: Concurrency</p>
<h2 id="1-processes-and-threads">1. Processes and Threads</h2>
<p>In concurrent programming, there are two basic units of execution: processes and threads. Most implementations of the Java virtual machine run as a single process.</p>
<ul>
<li><strong>Processes</strong></li>
</ul>
<p>A process has a self-contained execution environment. A process generally has a complete, private set of basic run-time resources; in particular, each process has its own memory space. To facilitate communication between processes, most operating systems support Inter Process Communication (IPC) resources, such as pipes and sockets. IPC is used not just for communication between processes on the same system, but processes on different systems.</p>
<ul>
<li><strong>Threads</strong></li>
</ul>
<p>Threads exist within a process &#x2014; every process has at least one. Threads share the process&apos;s resources, including memory and open files. This makes for efficient, but potentially problematic, communication.</p>
<p>Every application has at least one thread &#x2014; or several, if you count &quot;system&quot; threads that do things like memory management and signal handling. But from the application programmer&apos;s point of view, you start with just one thread, called the main thread. This thread has the ability to create additional threads.</p>
<h2 id="2-implement-multithread">2. Implement Multithread</h2>
<ul>
<li><strong>extends Thread </strong></li>
</ul>
<pre><code>1. Thread() // create a new thread object
2. Thread(Runnable target) // create a new thread object based on Runnable
3. Thread(Runnable t, String name) // assign a name for thread
4. Thread(String name) // create a new thread object with an assgned name
</code></pre><ul>
<li><strong>implement Runnable</strong></li>
</ul>
<pre><code>1. Need to @Overrid run()
2. It is good for shared resources scenario.
</code></pre><p><strong>Example: </strong></p>
<pre><code>// Extends Thread
public class MyThread extends Thread {
@Override
public void run() {
for (int i = 0; i &lt; 20; i++) {
System.out.println(&quot;MyThread is running&quot;);
}
}
}
</code></pre><pre><code>// Implement Runnable
public class MyRunnable implements Runnable {
@Override
public void run() {
for(int i = 0; i &lt; 20; i++) {
System.out.println(&quot;MyRunnable is running&quot;);
}
}
}
</code></pre><pre><code>// Test two cases
public class A_StartingThreads {
public static void main(String[] args) {
MyThread myThread = new MyThread();
myThread.run();
MyRunnable myRunnable = new MyRunnable();
myRunnable.run();

/*
* Common pitfall: Calling run() instead of start()
* */
Thread thread = new Thread(new MyRunnable());
thread.start();
for (int i = 0; i &lt; 10; i++) {
new Thread(&quot;&quot; + i){
public void run() {
System.out.println(&quot;Thread: &quot; + getName() + &quot; is running&quot; );
}
}.start();
}
}
}
</code></pre><p>Summary:</p>
<pre><code>Note: Use start() to invoke Thread, not run() method.
* Runnable way is preferable.
1 When having the Runnable&apos;s executed by a thread pool it is easy to queue up the Runnable instances until a thread from the pool is idle.
2 Sometimes you may have to implement Runnable as well as subclass Thread. For instance, if creating a subclass of Thread that can execute more than one Runnable.
</code></pre><h2 id="3-thread-life-cycle">3. Thread Life Cycle</h2>
<p><img src="thread.png" alt="">
<strong>Five States: </strong></p>
<ul>
<li>NEW</li>
<li>Runnable</li>
<li>Running (yield)</li>
<li>Blocking (wait / sleep / suspend)</li>
<li>Dead</li>
</ul>
<p><strong>sleep()</strong> method:</p>
<pre><code>Thread.sleep(1000) // sleep 1 second

// interrupt() can wake up the sleep thread
</code></pre><p><strong>join()</strong> method:</p>
<pre><code>@Override
public void run() {
// some job
Thread_out.join(); // current thread will be blocked until this Thread_out completes its job
}
</code></pre><p><strong>isAlive()</strong>: it is used to check if current thread is runnable or running.</p>
<h2 id="3-thread-priority">3. Thread Priority</h2>
<ul>
<li><p>Java uses [1 - 10] to setup priority. 10 has the highest priority and 0 has the lowest priority.</p>
</li>
<li><p>3 constant thread priority</p>
</li>
<li>MAX_PRIORITY: 10</li>
<li>MIN_PRIORITY: 0</li>
<li><p>NORM_PRIORITY: 5</p>
</li>
<li><p>Thread.setPriority() / Thread.getPriority()</p>
</li>
</ul>
<p>Note: JVM cannot guarantee that the higher priority thread will run before the lower ones.</p>
<h2 id="4-thread-synchronization">4. Thread Synchronization</h2>
<ul>
<li><strong>Thread Interference</strong> describes how errors are introduced when multiple threads access shared data.</li>
<li><strong>Memory Consistency Errors</strong> describes errors that result from inconsistent views of shared memory.</li>
<li><strong>Synchronized Methods</strong> describes a simple idiom that can effectively prevent thread interference and memory consistency errors.</li>
<li><strong>Implicit Locks and Synchronization</strong> describes a more general synchronization idiom, and describes how synchronization is based on implicit locks.</li>
<li><strong>Atomic Access</strong> talks about the general idea of operations that can&apos;t be interfered with by other threads.</li>
</ul>
<h3 id="41-thread-interference">4.1 Thread Interference</h3>
<p>Consider a simple class called Counter</p>
<pre><code class="lang-java">class Counter {
private int c = 0;
public void increment() {
c++;
}
public void decrement() {
c--;
}
public int value() {
return c;
}
}
</code></pre>
<p>Interference happens when two operations, running in different threads, but acting on the same data, interleave. This means that the two operations consist of multiple steps, and the sequences of steps overlap.</p>
<p>Note the single expression c++ can be decomposed into three steps:</p>
<pre><code>Retrieve the current value of c.
Increment the retrieved value by 1.
Store the incremented value back in c.
</code></pre><p>Suppose Thread A invokes increment at about the same time Thread B invokes decrement. If the initial value of c is 0, their interleaved actions might follow this sequence:</p>
<pre><code>1. Thread A: Retrieve c.
2. Thread B: Retrieve c.
3. Thread A: Increment retrieved value; result is 1.
4. Thread B: Decrement retrieved value; result is -1.
5. Thread A: Store result in c; c is now 1.
6. Thread B: Store result in c; c is now -1.
</code></pre><p>Thread A&apos;s result is lost, overwritten by Thread B. This particular interleaving is only one possibility. Under different circumstances it might be Thread B&apos;s result that gets lost, or there could be no error at all. Because they are unpredictable, thread interference bugs can be difficult to detect and fix.</p>
<h3 id="42-memory-consistency-errors">4.2 Memory Consistency Errors</h3>
<p>Memory consistency errors occur when different threads have inconsistent views of what should be the same data. The programmer does not need a detailed understanding of these causes. All that is needed is a strategy for avoiding them.</p>
<p>The key to avoiding memory consistency errors is understanding the happens-before relationship. This relationship is simply a guarantee that memory writes by one specific statement are visible to another specific statement. To see this, consider the following example. Suppose a simple int field is defined and initialized:</p>
<pre><code class="lang-java">int counter = 0;
</code></pre>
<p>The counter field is shared between two threads, A and B. Suppose thread A increments counter:</p>
<pre><code class="lang-java">counter++;
</code></pre>
<p>Then, shortly afterwards, thread B prints out counter:</p>
<pre><code class="lang-java">System.out.println(counter);
</code></pre>
<p>If the two statements had been executed in the same thread, it would be safe to assume that the value printed out would be <strong>1</strong>. But if the two statements are executed in separate threads, the value printed out might well be <strong>0</strong>, because there&apos;s no guarantee that thread A&apos;s change to counter will be visible to thread B &#x2014; unless the programmer has established a happens-before relationship between these two statements.</p>
<p>There are several actions that create happens-before relationships. One of them is <strong>synchronization</strong>, as we will see in the following sections.</p>
<p>We&apos;ve already seen two actions that create happens-before relationships.</p>
<ul>
<li>When a statement invokes Thread.start, every statement that has a happens-before relationship with that statement also has a happens-before relationship with every statement executed by the new thread. The effects of the code that led up to the creation of the new thread are visible to the new thread.</li>
<li>When a thread terminates and causes a Thread.join in another thread to return, then all the statements executed by the terminated thread have a happens-before relationship with all the statements following the successful join. The effects of the code in the thread are now visible to the thread that performed the join.</li>
</ul>
<p>For a list of actions that create happens-before relationships, refer to the Summary page of the java.util.concurrent package..</p>
<h3 id="43-synchronized-methods">4.3 Synchronized Methods</h3>
<p>The Java programming language provides two basic synchronization idioms:</p>
<ul>
<li>synchronized methods</li>
<li>synchronized statements</li>
</ul>
<p>This section is about synchronized methods.</p>
<p>To make a method synchronized, simply add the synchronized keyword to its declaration:</p>
<pre><code class="lang-java">public class SynchronizedCounter {
private int c = 0;

public synchronized void increment() {
c++;
}

public synchronized void decrement() {
c--;
}

public synchronized int value() {
return c;
}
}
</code></pre>
<p>If count is an instance of SynchronizedCounter, then making these methods synchronized has two effects:</p>
<ul>
<li>First, it is not possible for two invocations of synchronized methods on the same object to interleave. When one thread is executing a synchronized method for an object, all other threads that invoke synchronized methods for the same object block (suspend execution) until the first thread is done with the object.</li>
<li>Second, when a synchronized method exits, it automatically establishes a happens-before relationship with any subsequent invocation of a synchronized method for the same object. This guarantees that changes to the state of the object are visible to all threads.</li>
</ul>
<p>Note that constructors cannot be synchronized &#x2014; using the synchronized keyword with a constructor is a syntax error. Synchronizing constructors doesn&apos;t make sense, because only the thread that creates an object should have access to it while it is being constructed.</p>
<p><strong>Warning</strong>: When constructing an object that will be shared between threads, be very careful that a reference to the object does not &quot;leak&quot; prematurely. For example, suppose you want to maintain a <code>List</code> called instances containing every instance of class. You might be tempted to add the following line to your constructor:</p>
<pre><code class="lang-java">instances.add(this);
</code></pre>
<p>But then other threads can use instances to access the object before construction of the object is complete.</p>
<p>Synchronized methods enable a simple strategy for preventing thread interference and memory consistency errors: if an object is visible to more than one thread, all reads or writes to that object&apos;s variables are done through synchronized methods. (An important exception: <code>final</code> fields, which cannot be modified after the object is constructed, can be safely read through non-synchronized methods, once the object is constructed) This strategy is effective, but can present problems with liveness, as we&apos;ll see later in this lesson.</p>
<h3 id="44-intrinsic-locks-and-synchronization">4.4 Intrinsic Locks and Synchronization</h3>
<p>Synchronization is built around an internal entity known as the <strong>intrinsic lock</strong> or <strong>monitor lock</strong>. (The API specification often refers to this entity simply as a &quot;monitor.&quot;) Intrinsic locks play a role in both aspects of synchronization: enforcing exclusive access to an object&apos;s state and establishing happens-before relationships that are essential to visibility.</p>
<p>Every object has an intrinsic lock associated with it. By convention, a thread that needs exclusive and consistent access to an object&apos;s fields has to acquire the object&apos;s intrinsic lock before accessing them, and then release the intrinsic lock when it&apos;s done with them. A thread is said to own the intrinsic lock between the time it has acquired the lock and released the lock. As long as a thread owns an intrinsic lock, no other thread can acquire the same lock. The other thread will block when it attempts to acquire the lock.</p>
<p>When a thread releases an intrinsic lock, a happens-before relationship is established between that action and any subsequent acquisition of the same lock.</p>
<p><strong>Locks In Synchronized Methods</strong></p>
<p>When a thread invokes a synchronized method, it automatically acquires the intrinsic lock for that method&apos;s object and releases it when the method returns. The lock release occurs even if the return was caused by an uncaught exception.</p>
<p>You might wonder what happens when a static synchronized method is invoked, since a static method is associated with a class, not an object. In this case, the thread acquires the intrinsic lock for the Class object associated with the class. Thus access to class&apos;s static fields is controlled by a lock that&apos;s distinct from the lock for any instance of the class.</p>
<p><strong>Synchronized Statements</strong></p>
<p>Another way to create synchronized code is with synchronized statements. Unlike synchronized methods, synchronized statements must specify the object that provides the intrinsic lock:</p>
<pre><code class="lang-java">public void addName(String name) {
synchronized(this) {
lastName = name;
nameCount++;
}
nameList.add(name);
}
</code></pre>
<p>In this example, the <code>addName</code> method needs to synchronize changes to <code>lastName</code> and <code>nameCount</code>, but also needs to avoid synchronizing invocations of other objects&apos; methods. (Invoking other objects&apos; methods from synchronized code can create problems that are described in the section on Liveness.) Without synchronized statements, there would have to be a separate, unsynchronized method for the sole purpose of invoking <code>nameList.add</code>.</p>
<p>Synchronized statements are also useful for improving concurrency with fine-grained synchronization. Suppose, for example, class MsLunch has two instance fields, c1 and c2, that are never used together. All updates of these fields must be synchronized, but there&apos;s no reason to prevent an update of c1 from being interleaved with an update of c2 &#x2014; and doing so reduces concurrency by creating unnecessary blocking. Instead of using synchronized methods or otherwise using the lock associated with this, we create two objects solely to provide locks.</p>
<pre><code class="lang-java">public class MsLunch {
private long c1 = 0;
private long c2 = 0;
private Object lock1 = new Object();
private Object lock2 = new Object();

public void inc1() {
synchronized(lock1) {
c1++;
}
}

public void inc2() {
synchronized(lock2) {
c2++;
}
}
}
</code></pre>
<p>Use this idiom with extreme care. You must be absolutely sure that it really is safe to interleave access of the affected fields.</p>
<p><strong>Reentrant Synchronization</strong></p>
<p>Recall that a thread cannot acquire a lock owned by another thread. But a thread can acquire a lock that it already owns. Allowing a thread to acquire the same lock more than once enables reentrant synchronization. This describes a situation where synchronized code, directly or indirectly, invokes a method that also contains synchronized code, and both sets of code use the same lock. Without reentrant synchronization, synchronized code would have to take many additional precautions to avoid having a thread cause itself to block.</p>
<h3 id="45-atomic-access">4.5 Atomic Access</h3>
<p>In programming, an atomic action is one that effectively happens all at once. An atomic action cannot stop in the middle: it either happens completely, or it doesn&apos;t happen at all. No side effects of an atomic action are visible until the action is complete.</p>
<p>We have already seen that an increment expression, such as c++, does not describe an atomic action. Even very simple expressions can define complex actions that can decompose into other actions. However, there are actions you can specify that are atomic:</p>
<ul>
<li>Reads and writes are atomic for <strong>reference variables</strong> and for <strong>most primitive variables</strong> (all types except long and double).</li>
<li>Reads and writes are atomic for <strong>all variables declared volatile</strong> (including long and double variables).
Atomic actions cannot be interleaved, so they can be used without fear of thread interference. However, this does not eliminate all need to synchronize atomic actions, because memory consistency errors are still possible. Using <code>volatile</code> variables reduces the risk of memory consistency errors, because any write to a volatile variable establishes a happens-before relationship with subsequent reads of that same variable. This means that changes to a volatile variable are always visible to other threads. What&apos;s more, it also means that when a thread reads a volatile variable, it sees not just the latest change to the volatile, but also the side effects of the code that led up the change.</li>
</ul>
<p>Using simple atomic variable access is more efficient than accessing these variables through synchronized code, but requires more care by the programmer to avoid memory consistency errors. Whether the extra effort is worthwhile depends on the size and complexity of the application.</p>
<p>Some of the classes in the java.util.concurrent package provide atomic methods that do not rely on synchronization. We&apos;ll discuss them in the section on High Level Concurrency Objects.</p>
<h2 id="5-liveness">5. Liveness</h2>
<ul>
<li>Deadlock</li>
<li>Starvation and Livelock</li>
</ul>
<h3 id="51-deadlock">5.1 Deadlock</h3>
<p>When Deadlock runs, it&apos;s extremely likely that both threads will block when they attempt to invoke bowBack. Neither block will ever end, because each thread is waiting for the other to exit bow.</p>
<pre><code class="lang-java">public class Deadlock {
static class Friend {
private final String name;
public Friend(String name) {
this.name = name;
}
public String getName() {
return this.name;
}
public synchronized void bow(Friend bower) {
System.out.format(&quot;%s: %s&quot;
+ &quot; has bowed to me!%n&quot;,
this.name, bower.getName());
bower.bowBack(this);
}
public synchronized void bowBack(Friend bower) {
System.out.format(&quot;%s: %s&quot;
+ &quot; has bowed back to me!%n&quot;,
this.name, bower.getName());
}
}

public static void main(String[] args) {
final Friend alphonse = new Friend(&quot;Alphonse&quot;);
final Friend gaston = new Friend(&quot;Gaston&quot;);
new Thread(new Runnable() {
public void run() { alphonse.bow(gaston); }
}).start();
new Thread(new Runnable() {
public void run() { gaston.bow(alphonse); }
}).start();
}
}
</code></pre>
<h3 id="52-starvation-and-livelock">5.2 Starvation and Livelock</h3>
<ul>
<li><p><strong>Starvation</strong> describes a situation where a thread is unable to gain regular access to shared resources and is unable to make progress. This happens when shared resources are made unavailable for long periods by &quot;greedy&quot; threads. For example, suppose an object provides a synchronized method that often takes a long time to return. If one thread invokes this method frequently, other threads that also need frequent synchronized access to the same object will often be blocked.</p>
</li>
<li><p><strong>Livelock</strong>: A thread often acts in response to the action of another thread. If the other thread&apos;s action is also a response to the action of another thread, then livelock may result. As with deadlock, livelocked threads are unable to make further progress. However, the threads are not blocked &#x2014; they are simply too busy responding to each other to resume work. This is comparable to two people attempting to pass each other in a corridor: Alphonse moves to his left to let Gaston pass, while Gaston moves to his right to let Alphonse pass. Seeing that they are still blocking each other, Alphone moves to his right, while Gaston moves to his left. They&apos;re still blocking each other, so...</p>
</li>
</ul>
<h2 id="6-guarded-blocks">6. Guarded Blocks</h2>
<p>Threads often have to coordinate their actions. The most common coordination idiom is the guarded block. Such a block begins by polling a condition that must be true before the block can proceed. There are a number of steps to follow in order to do this correctly.</p>
<p>Suppose, for example guardedJoy is a method that must not proceed until a shared variable joy has been set by another thread. Such a method could, in theory, simply loop until the condition is satisfied, but that loop is wasteful, since it executes continuously while waiting.</p>
<pre><code class="lang-java">public void guardedJoy() {
// Simple loop guard. Wastes
// processor time. Don&apos;t do this!
while(!joy) {}
System.out.println(&quot;Joy has been achieved!&quot;);
}
</code></pre>
<p>A more efficient guard invokes Object.wait to suspend the current thread. The invocation of wait does not return until another thread has issued a notification that some special event may have occurred &#x2014; though not necessarily the event this thread is waiting for:</p>
<pre><code class="lang-java">public synchronized void guardedJoy() {
// This guard only loops once for each special event, which may not
// be the event we&apos;re waiting for.
while(!joy) {
try {
wait();
} catch (InterruptedException e) {}
}
System.out.println(&quot;Joy and efficiency have been achieved!&quot;);
}
</code></pre>
<p><strong>Note</strong>: Always invoke wait inside a loop that tests for the condition being waited for. Don&apos;t assume that the interrupt was for the particular condition you were waiting for, or that the condition is still true.</p>
<p>Like many methods that suspend execution, wait can throw InterruptedException. In this example, we can just ignore that exception &#x2014; we only care about the value of joy.</p>
<p>Why is this version of guardedJoy synchronized? Suppose d is the object we&apos;re using to invoke wait. When a thread invokes d.wait, it must own the intrinsic lock for d &#x2014; otherwise an error is thrown. Invoking wait inside a synchronized method is a simple way to acquire the intrinsic lock.</p>
<p>When wait is invoked, the thread releases the lock and suspends execution. At some future time, another thread will acquire the same lock and invoke Object.notifyAll, informing all threads waiting on that lock that something important has happened:</p>
<pre><code class="lang-java">public synchronized notifyJoy() {
joy = true;
notifyAll();
}
</code></pre>
<p>Some time after the second thread has released the lock, the first thread reacquires the lock and resumes by returning from the invocation of wait.</p>
<p><strong>Note</strong>: There is a second notification method, notify, which wakes up a single thread. Because notify doesn&apos;t allow you to specify the thread that is woken up, it is useful only in massively parallel applications &#x2014; that is, programs with a large number of threads, all doing similar chores. In such an application, you don&apos;t care which thread gets woken up.</p>
<p>Let&apos;s use guarded blocks to create a Producer-Consumer application. This kind of application shares data between two threads: the producer, that creates the data, and the consumer, that does something with it. The two threads communicate using a shared object. Coordination is essential: the consumer thread must not attempt to retrieve the data before the producer thread has delivered it, and the producer thread must not attempt to deliver new data if the consumer hasn&apos;t retrieved the old data.</p>
<p>In this example, the data is a series of text messages, which are shared through an object of type Drop:</p>
<pre><code class="lang-java">public class Drop {
// Message sent from producer
// to consumer.
private String message;
// True if consumer should wait
// for producer to send message,
// false if producer should wait for
// consumer to retrieve message.
private boolean empty = true;

public synchronized String take() {
// Wait until message is
// available.
while (empty) {
try {
wait();
} catch (InterruptedException e) {}
}
// Toggle status.
empty = true;
// Notify producer that
// status has changed.
notifyAll();
return message;
}

public synchronized void put(String message) {
// Wait until message has
// been retrieved.
while (!empty) {
try {
wait();
} catch (InterruptedException e) {}
}
// Toggle status.
empty = false;
// Store message.
this.message = message;
// Notify consumer that status
// has changed.
notifyAll();
}
}
</code></pre>
<p>The producer thread, defined in Producer, sends a series of familiar messages. The string &quot;DONE&quot; indicates that all messages have been sent. To simulate the unpredictable nature of real-world applications, the producer thread pauses for random intervals between messages.</p>
<pre><code class="lang-java">import java.util.Random;

public class Producer implements Runnable {
private Drop drop;

public Producer(Drop drop) {
this.drop = drop;
}

public void run() {
String importantInfo[] = {
&quot;Mares eat oats&quot;,
&quot;Does eat oats&quot;,
&quot;Little lambs eat ivy&quot;,
&quot;A kid will eat ivy too&quot;
};
Random random = new Random();

for (int i = 0;
i &lt; importantInfo.length;
i++) {
drop.put(importantInfo[i]);
try {
Thread.sleep(random.nextInt(5000));
} catch (InterruptedException e) {}
}
drop.put(&quot;DONE&quot;);
}
}
</code></pre>
<p>The consumer thread, defined in Consumer, simply retrieves the messages and prints them out, until it retrieves the &quot;DONE&quot; string. This thread also pauses for random intervals.</p>
<pre><code class="lang-java">import java.util.Random;

public class Consumer implements Runnable {
private Drop drop;

public Consumer(Drop drop) {
this.drop = drop;
}

public void run() {
Random random = new Random();
for (String message = drop.take();
! message.equals(&quot;DONE&quot;);
message = drop.take()) {
System.out.format(&quot;MESSAGE RECEIVED: %s%n&quot;, message);
try {
Thread.sleep(random.nextInt(5000));
} catch (InterruptedException e) {}
}
}
}
</code></pre>
<p>Finally, here is the main thread, defined in ProducerConsumerExample, that launches the producer and consumer threads.</p>
<pre><code class="lang-java">public class ProducerConsumerExample {
public static void main(String[] args) {
Drop drop = new Drop();
(new Thread(new Producer(drop))).start();
(new Thread(new Consumer(drop))).start();
}
}
</code></pre>
<p>Note: The Drop class was written in order to demonstrate guarded blocks. To avoid re-inventing the wheel, examine the existing data structures in the Java Collections Framework before trying to code your own data-sharing objects. For more information, refer to the Questions and Exercises section.</p>
<h2 id="7-immutable-objects">7. Immutable Objects</h2>
<p>An object is considered immutable if its state cannot change after it is constructed. Maximum reliance on immutable objects is widely accepted as a sound strategy for creating simple, reliable code.</p>
<p>Immutable objects are particularly useful in concurrent applications. Since they cannot change state, they cannot be corrupted by thread interference or observed in an inconsistent state.</p>
<p>Programmers are often reluctant to employ immutable objects, because they worry about the cost of creating a new object as opposed to updating an object in place. The impact of object creation is often overestimated, and can be offset by some of the efficiencies associated with immutable objects. These include decreased overhead due to garbage collection, and the elimination of code needed to protect mutable objects from corruption.</p>
<p>The following subsections take a class whose instances are mutable and derives a class with immutable instances from it. In so doing, they give general rules for this kind of conversion and demonstrate some of the advantages of immutable objects.</p>
<h3 id="71-a-synchronized-class-example">7.1 A Synchronized Class Example</h3>
<pre><code class="lang-java">public class SynchronizedRGB {

// Values must be between 0 and 255.
private int red;
private int green;
private int blue;
private String name;

private void check(int red,int green,int blue) {
if (red &lt; 0 || red &gt; 255
|| green &lt; 0 || green &gt; 255
|| blue &lt; 0 || blue &gt; 255) {
throw new IllegalArgumentException();
}
}

public SynchronizedRGB(int red,int green,int blue,String name) {
check(red, green, blue);
this.red = red;
this.green = green;
this.blue = blue;
this.name = name;
}

public void set(int red,int green,int blue, String name) {
check(red, green, blue);
synchronized (this) {
this.red = red;
this.green = green;
this.blue = blue;
this.name = name;
}
}

public synchronized int getRGB() {
return ((red &lt;&lt; 16) | (green &lt;&lt; 8) | blue);
}

public synchronized String getName() {
return name;
}

public synchronized void invert() {
red = 255 - red;
green = 255 - green;
blue = 255 - blue;
name = &quot;Inverse of &quot; + name;
}
}
</code></pre>
<p>SynchronizedRGB must be used carefully to avoid being seen in an inconsistent state. Suppose, for example, a thread executes the following code:</p>
<pre><code class="lang-java">SynchronizedRGB color = new SynchronizedRGB(0, 0, 0, &quot;Pitch Black&quot;);
...
int myColorInt = color.getRGB(); //Statement 1
String myColorName = color.getName(); //Statement 2
</code></pre>
<p>If another thread invokes color.set after Statement 1 but before Statement 2, the value of myColorInt won&apos;t match the value of myColorName. To avoid this outcome, the two statements must be bound together:</p>
<pre><code class="lang-java">synchronized (color) {
int myColorInt = color.getRGB();
String myColorName = color.getName();
}
</code></pre>
<p>This kind of inconsistency is only possible for mutable objects &#x2014; it will not be an issue for the immutable version of SynchronizedRGB.</p>
<h3 id="72-a-strategy-for-defining-immutable-objects">7.2 A Strategy for Defining Immutable Objects</h3>
<p>The following rules define a simple strategy for creating immutable objects. Not all classes documented as &quot;immutable&quot; follow these rules. This does not necessarily mean the creators of these classes were sloppy &#x2014; they may have good reason for believing that instances of their classes never change after construction. However, such strategies require sophisticated analysis and are not for beginners.</p>
<ul>
<li>Don&apos;t provide &quot;setter&quot; methods &#x2014; methods that modify fields or objects referred to by fields.</li>
<li>Make all fields <code>final</code> and <code>private</code>.</li>
<li>Don&apos;t allow subclasses to override methods. The simplest way to do this is to declare the class as <code>final</code>. A more sophisticated approach is to make the constructor <code>private</code> and construct instances in factory methods.</li>
<li>If the instance fields include references to mutable objects, don&apos;t allow those objects to be changed:</li>
<li>Don&apos;t provide methods that modify the mutable objects.</li>
<li>Don&apos;t share references to the mutable objects. Never store references to external, mutable objects passed to the constructor; if necessary, create copies, and store references to the copies. Similarly, create copies of your internal mutable objects when necessary to avoid returning the originals in your methods.</li>
</ul>
<p>Applying this strategy to SynchronizedRGB results in the following steps:</p>
<ul>
<li>There are two setter methods in this class. The first one, set, arbitrarily transforms the object, and has no place in an immutable version of the class. The second one, invert, can be adapted by having it create a new object instead of modifying the existing one.</li>
<li>All fields are already private; they are further qualified as final.</li>
<li>The class itself is declared final.</li>
<li>Only one field refers to an object, and that object is itself immutable. Therefore, no safeguards against changing the state of &quot;contained&quot; mutable objects are necessary.</li>
</ul>
<pre><code class="lang-java">final public class ImmutableRGB {

// Values must be between 0 and 255.
final private int red;
final private int green;
final private int blue;
final private String name;

private void check(int red,int green,int blue) {
if (red &lt; 0 || red &gt; 255
|| green &lt; 0 || green &gt; 255
|| blue &lt; 0 || blue &gt; 255) {
throw new IllegalArgumentException();
}
}

public ImmutableRGB(int red,int green,int blue,String name) {
check(red, green, blue);
this.red = red;
this.green = green;
this.blue = blue;
this.name = name;
}

public int getRGB() {
return ((red &lt;&lt; 16) | (green &lt;&lt; 8) | blue);
}

public String getName() {
return name;
}

public ImmutableRGB invert() {
return new ImmutableRGB(255 - red,
255 - green,
255 - blue,
&quot;Inverse of &quot; + name);
}
}
</code></pre>
<h2 id="8-high-level-concurrency-objects">8. High Level Concurrency Objects</h2>
<p>Most of these features are implemented in the new <code>java.util.concurrent</code> packages. There are also new concurrent data structures in the Java Collections Framework.</p>
<ul>
<li><strong>Lock objects:</strong> support locking idioms that simplify many concurrent applications.</li>
<li><strong>Executors: </strong> define a high-level API for launching and managing threads.</li>
<li><strong>Concurrent collections: </strong> make it easier to manage large collections of data, and can greatly reduce the need for synchronization.</li>
<li><strong>Atomic variables: </strong> have features that minimize synchronization and help avoid memory consistency errors.</li>
<li><strong>ThreadLocalRandom</strong> (in JDK 7) provides efficient generation of pseudorandom numbers from multiple threads.</li>
</ul>
<h3 id="81-lock-objects">8.1 Lock Objects</h3>
<p>Synchronized code relies on a simple kind of reentrant lock. This kind of lock is easy to use, but has many limitations. More sophisticated locking idioms are supported by the java.util.concurrent.locks package.</p>
<p><code>Lock</code> objects work very much like the implicit locks used by synchronized code. As with implicit locks, only one thread can own a Lock object at a time. Lock objects also support a wait/notify mechanism, through their associated Condition objects.</p>
<p><strong>The biggest advantage</strong> of Lock objects over implicit locks is their ability to back out of an attempt to acquire a lock. The <code>tryLock</code> method backs out if the lock is not available immediately or before a timeout expires (if specified). The <code>lockInterruptibly</code> method backs out if another thread sends an interrupt before the lock is acquired.</p>
<p>Let&apos;s use Lock objects to solve the deadlock problem we saw in Liveness. Alphonse and Gaston have trained themselves to notice when a friend is about to bow. We model this improvement by requiring that our Friend objects must acquire locks for both participants before proceeding with the bow. Here is the source code for the improved model, Safelock. To demonstrate the versatility of this idiom, we assume that Alphonse and Gaston are so infatuated with their newfound ability to bow safely that they can&apos;t stop bowing to each other:</p>
<pre><code class="lang-java">import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.Random;

public class Safelock {
static class Friend {
private final String name;
private final Lock lock = new ReentrantLock();

public Friend(String name) {
this.name = name;
}

public String getName() {
return this.name;
}

public boolean impendingBow(Friend bower) {
Boolean myLock = false;
Boolean yourLock = false;
try {
myLock = lock.tryLock();
yourLock = bower.lock.tryLock();
} finally {
if (! (myLock &amp;&amp; yourLock)) {
if (myLock) {
lock.unlock();
}
if (yourLock) {
bower.lock.unlock();
}
}
}
return myLock &amp;&amp; yourLock;
}
public void bow(Friend bower) {
if (impendingBow(bower)) {
try {
System.out.format(&quot;%s: %s has&quot;
+ &quot; bowed to me!%n&quot;,
this.name, bower.getName());
bower.bowBack(this);
} finally {
lock.unlock();
bower.lock.unlock();
}
} else {
System.out.format(&quot;%s: %s started&quot;
+ &quot; to bow to me, but saw that&quot;
+ &quot; I was already bowing to&quot;
+ &quot; him.%n&quot;,
this.name, bower.getName());
}
}

public void bowBack(Friend bower) {
System.out.format(&quot;%s: %s has&quot; +
&quot; bowed back to me!%n&quot;,
this.name, bower.getName());
}
}

static class BowLoop implements Runnable {
private Friend bower;
private Friend bowee;

public BowLoop(Friend bower, Friend bowee) {
this.bower = bower;
this.bowee = bowee;
}
public void run() {
Random random = new Random();
for (;;) {
try {
Thread.sleep(random.nextInt(10));
} catch (InterruptedException e) {}
bowee.bow(bower);
}
}
}
public static void main(String[] args) {
final Friend alphonse = new Friend(&quot;Alphonse&quot;);
final Friend gaston = new Friend(&quot;Gaston&quot;);
new Thread(new BowLoop(alphonse, gaston)).start();
new Thread(new BowLoop(gaston, alphonse)).start();
}
}
</code></pre>
<h3 id="82-executors">8.2 Executors</h3>
<p>In all of the previous examples, there&apos;s a close connection between the task being done by a new thread, as defined by its Runnable object, and the thread itself, as defined by a Thread object. This works well for small applications, but in large-scale applications, it makes sense to separate thread management and creation from the rest of the application. Objects that encapsulate these functions are known as executors. The following subsections describe executors in detail.</p>
<ul>
<li><strong>Executor Interfaces</strong> define the three executor object types.</li>
<li><strong>Thread Pools</strong> are the most common kind of executor implementation.</li>
<li><strong>Fork/Join</strong> is a framework (new in JDK 7) for taking advantage of multiple processors.</li>
</ul>
<h4 id="821-executor-interfaces">8.2.1 Executor Interfaces</h4>
<p>The java.util.concurrent package defines three executor interfaces:</p>
<p>Executor, a simple interface that supports launching new tasks.
ExecutorService, a subinterface of Executor, which adds features that help manage the lifecycle, both of the individual tasks and of the executor itself.
ScheduledExecutorService, a subinterface of ExecutorService, supports future and/or periodic execution of tasks.
Typically, variables that refer to executor objects are declared as one of these three interface types, not with an executor class type.</p>
<p>The Executor Interface</p>
<p>The Executor interface provides a single method, execute, designed to be a drop-in replacement for a common thread-creation idiom. If r is a Runnable object, and e is an Executor object you can replace</p>
<p>(new Thread(r)).start();
with</p>
<p>e.execute(r);
However, the definition of execute is less specific. The low-level idiom creates a new thread and launches it immediately. Depending on the Executor implementation, execute may do the same thing, but is more likely to use an existing worker thread to run r, or to place r in a queue to wait for a worker thread to become available. (We&apos;ll describe worker threads in the section on Thread Pools.)</p>
<p>The executor implementations in java.util.concurrent are designed to make full use of the more advanced ExecutorService and ScheduledExecutorService interfaces, although they also work with the base Executor interface.</p>
<p>The ExecutorService Interface</p>
<p>The ExecutorService interface supplements execute with a similar, but more versatile submit method. Like execute, submit accepts Runnable objects, but also accepts Callable objects, which allow the task to return a value. The submit method returns a Future object, which is used to retrieve the Callable return value and to manage the status of both Callable and Runnable tasks.</p>
<p>ExecutorService also provides methods for submitting large collections of Callable objects. Finally, ExecutorService provides a number of methods for managing the shutdown of the executor. To support immediate shutdown, tasks should handle interrupts correctly.</p>
<p>The ScheduledExecutorService Interface</p>
<p>The ScheduledExecutorService interface supplements the methods of its parent ExecutorService with schedule, which executes a Runnable or Callable task after a specified delay. In addition, the interface defines scheduleAtFixedRate and scheduleWithFixedDelay, which executes specified tasks repeatedly, at defined intervals.</p>
<h4 id="822-thread-pools">8.2.2 Thread Pools</h4>
<p>Most of the executor implementations in java.util.concurrent use thread pools, which consist of worker threads. This kind of thread exists separately from the Runnable and Callable tasks it executes and is often used to execute multiple tasks.</p>
<p>Using worker threads minimizes the overhead due to thread creation. Thread objects use a significant amount of memory, and in a large-scale application, allocating and deallocating many thread objects creates a significant memory management overhead.</p>
<p>One common type of thread pool is the fixed thread pool. This type of pool always has a specified number of threads running; if a thread is somehow terminated while it is still in use, it is automatically replaced with a new thread. Tasks are submitted to the pool via an internal queue, which holds extra tasks whenever there are more active tasks than threads.</p>
<p>An important advantage of the fixed thread pool is that applications using it degrade gracefully. To understand this, consider a web server application where each HTTP request is handled by a separate thread. If the application simply creates a new thread for every new HTTP request, and the system receives more requests than it can handle immediately, the application will suddenly stop responding to all requests when the overhead of all those threads exceed the capacity of the system. With a limit on the number of the threads that can be created, the application will not be servicing HTTP requests as quickly as they come in, but it will be servicing them as quickly as the system can sustain.</p>
<p>A simple way to create an executor that uses a fixed thread pool is to invoke the newFixedThreadPool factory method in java.util.concurrent.Executors This class also provides the following factory methods:</p>
<p>The newCachedThreadPool method creates an executor with an expandable thread pool. This executor is suitable for applications that launch many short-lived tasks.
The newSingleThreadExecutor method creates an executor that executes a single task at a time.
Several factory methods are ScheduledExecutorService versions of the above executors.
If none of the executors provided by the above factory methods meet your needs, constructing instances of java.util.concurrent.ThreadPoolExecutor or java.util.concurrent.ScheduledThreadPoolExecutor will give you additional options.</p>
<h4 id="823-forkjoin">8.2.3 Fork/Join</h4>
<p>The fork/join framework is an implementation of the ExecutorService interface that helps you take advantage of multiple processors. It is designed for work that can be broken into smaller pieces recursively. The goal is to use all the available processing power to enhance the performance of your application.</p>
<p>As with any ExecutorService implementation, the fork/join framework distributes tasks to worker threads in a thread pool. The fork/join framework is distinct because it uses a <strong>work-stealing algorithm</strong>. Worker threads that run out of things to do can steal tasks from other threads that are still busy.</p>
<p>The center of the fork/join framework is the ForkJoinPool class, an extension of the AbstractExecutorService class. ForkJoinPool implements the core work-stealing algorithm and can execute ForkJoinTask processes.</p>
<h5 id="basic-use">Basic Use</h5>
<p>The first step for using the fork/join framework is to write code that performs a segment of the work. Your code should look similar to the following pseudocode:</p>
<p>if (my portion of the work is small enough)
do the work directly
else
split my work into two pieces
invoke the two pieces and wait for the results
Wrap this code in a ForkJoinTask subclass, typically using one of its more specialized types, either RecursiveTask (which can return a result) or RecursiveAction.</p>
<p>After your ForkJoinTask subclass is ready, create the object that represents all the work to be done and pass it to the invoke() method of a ForkJoinPool instance.</p>
<p>Blurring for Clarity</p>
<p>To help you understand how the fork/join framework works, consider the following example. Suppose that you want to blur an image. The original source image is represented by an array of integers, where each integer contains the color values for a single pixel. The blurred destination image is also represented by an integer array with the same size as the source.</p>
<p>Performing the blur is accomplished by working through the source array one pixel at a time. Each pixel is averaged with its surrounding pixels (the red, green, and blue components are averaged), and the result is placed in the destination array. Since an image is a large array, this process can take a long time. You can take advantage of concurrent processing on multiprocessor systems by implementing the algorithm using the fork/join framework. Here is one possible implementation:</p>
<p>public class ForkBlur extends RecursiveAction {
private int[] mSource;
private int mStart;
private int mLength;
private int[] mDestination;
// Processing window size; should be odd.
private int mBlurWidth = 15;
public ForkBlur(int[] src, int start, int length, int[] dst) {
mSource = src;
mStart = start;
mLength = length;
mDestination = dst;
}</p>
<p>protected void computeDirectly() {
int sidePixels = (mBlurWidth - 1) / 2;
for (int index = mStart; index &lt; mStart + mLength; index++) {
// Calculate average.
float rt = 0, gt = 0, bt = 0;
for (int mi = -sidePixels; mi &lt;= sidePixels; mi++) {
int mindex = Math.min(Math.max(mi + index, 0),
mSource.length - 1);
int pixel = mSource[mindex];
rt += (float)((pixel &amp; 0x00ff0000) &gt;&gt; 16)
/ mBlurWidth;
gt += (float)((pixel &amp; 0x0000ff00) &gt;&gt; 8)
/ mBlurWidth;
bt += (float)((pixel &amp; 0x000000ff) &gt;&gt; 0)
/ mBlurWidth;
}
// Reassemble destination pixel.
int dpixel = (0xff000000 ) |
(((int)rt) &lt;&lt; 16) |
(((int)gt) &lt;&lt; 8) |
(((int)bt) &lt;&lt; 0);
mDestination[index] = dpixel;
}
}
...
Now you implement the abstract compute() method, which either performs the blur directly or splits it into two smaller tasks. A simple array length threshold helps determine whether the work is performed or split.</p>
<p>protected static int sThreshold = 100000;</p>
<p>protected void compute() {
if (mLength &lt; sThreshold) {
computeDirectly();
return;
}
int split = mLength / 2;
invokeAll(new ForkBlur(mSource, mStart, split, mDestination),
new ForkBlur(mSource, mStart + split, mLength - split,
mDestination));
}
If the previous methods are in a subclass of the RecursiveAction class, then setting up the task to run in a ForkJoinPool is straightforward, and involves the following steps:</p>
<p>Create a task that represents all of the work to be done.</p>
<p>// source image pixels are in src
// destination image pixels are in dst
ForkBlur fb = new ForkBlur(src, 0, src.length, dst);
Create the ForkJoinPool that will run the task.</p>
<p>ForkJoinPool pool = new ForkJoinPool();
Run the task.</p>
<p>pool.invoke(fb);
For the full source code, including some extra code that creates the destination image file, see the ForkBlur example.</p>
<p>Standard Implementations</p>
<p>Besides using the fork/join framework to implement custom algorithms for tasks to be performed concurrently on a multiprocessor system (such as the ForkBlur.java example in the previous section), there are some generally useful features in Java SE which are already implemented using the fork/join framework. One such implementation, introduced in Java SE 8, is used by the java.util.Arrays class for its parallelSort() methods. These methods are similar to sort(), but leverage concurrency via the fork/join framework. Parallel sorting of large arrays is faster than sequential sorting when run on multiprocessor systems. However, how exactly the fork/join framework is leveraged by these methods is outside the scope of the Java Tutorials. For this information, see the Java API documentation.</p>
<p>Another implementation of the fork/join framework is used by methods in the java.util.streams package, which is part of Project Lambda scheduled for the Java SE 8 release. For more information, see the Lambda Expressions section.</p>
<h3 id="83-concurrent-collections">8.3 Concurrent Collections</h3>
<p>The java.util.concurrent package includes a number of additions to the Java Collections Framework. These are most easily categorized by the collection interfaces provided:</p>
<p>BlockingQueue defines a first-in-first-out data structure that blocks or times out when you attempt to add to a full queue, or retrieve from an empty queue.
ConcurrentMap is a subinterface of java.util.Map that defines useful atomic operations. These operations remove or replace a key-value pair only if the key is present, or add a key-value pair only if the key is absent. Making these operations atomic helps avoid synchronization. The standard general-purpose implementation of ConcurrentMap is ConcurrentHashMap, which is a concurrent analog of HashMap.
ConcurrentNavigableMap is a subinterface of ConcurrentMap that supports approximate matches. The standard general-purpose implementation of ConcurrentNavigableMap is ConcurrentSkipListMap, which is a concurrent analog of TreeMap.
All of these collections help avoid Memory Consistency Errors by defining a happens-before relationship between an operation that adds an object to the collection with subsequent operations that access or remove that object.</p>
<h3 id="84-atomic-variables">8.4 Atomic Variables</h3>
<p>The java.util.concurrent.atomic package defines classes that support atomic operations on single variables. All classes have get and set methods that work like reads and writes on volatile variables. That is, a set has a happens-before relationship with any subsequent get on the same variable. The atomic compareAndSet method also has these memory consistency features, as do the simple atomic arithmetic methods that apply to integer atomic variables.</p>
<p>To see how this package might be used, let&apos;s return to the Counter class we originally used to demonstrate thread interference:</p>
<p>class Counter {
private int c = 0;</p>
<p>public void increment() {
c++;
}</p>
<p>public void decrement() {
c--;
}</p>
<p>public int value() {
return c;
}</p>
<p>}
One way to make Counter safe from thread interference is to make its methods synchronized, as in SynchronizedCounter:</p>
<p>class SynchronizedCounter {
private int c = 0;</p>
<p>public synchronized void increment() {
c++;
}</p>
<p>public synchronized void decrement() {
c--;
}</p>
<p>public synchronized int value() {
return c;
}</p>
<p>}
For this simple class, synchronization is an acceptable solution. But for a more complicated class, we might want to avoid the liveness impact of unnecessary synchronization. Replacing the int field with an AtomicInteger allows us to prevent thread interference without resorting to synchronization, as in AtomicCounter:</p>
<p>import java.util.concurrent.atomic.AtomicInteger;</p>
<p>class AtomicCounter {
private AtomicInteger c = new AtomicInteger(0);</p>
<p>public void increment() {
c.incrementAndGet();
}</p>
<p>public void decrement() {
c.decrementAndGet();
}</p>
<p>public int value() {
return c.get();
}</p>
<p>}</p>
<h4 id="85-concurrent-random-numbers">8.5 Concurrent Random Numbers</h4>
<p>In JDK 7, java.util.concurrent includes a convenience class, ThreadLocalRandom, for applications that expect to use random numbers from multiple threads or ForkJoinTasks.</p>
<p>For concurrent access, using ThreadLocalRandom instead of Math.random() results in less contention and, ultimately, better performance.</p>
<p>All you need to do is call ThreadLocalRandom.current(), then call one of its methods to retrieve a random number. Here is one example:</p>
<p>int r = ThreadLocalRandom.current() .nextInt(4, 77);</p>
<h3 id="synchronization-questions">Synchronization Questions</h3>
<p><strong>Q: What is synchronization and why is it important? </strong></p>
<pre><code>A: With respect to multithreading, synchronization is the capability to control the access of multiple threads to shared resources. Without synchronization, it is possible for one thread to modify a shared object while another thread is in the process of using or updating that object&apos;s value. This often leads to significant errors.
</code></pre><p><strong>Q: What are synchronized methods and synchronized statements? </strong></p>
<pre><code>1): Synchronized methods are methods that are used to control access to an object. A thread only executes a synchronized method after it has acquired the lock for the method&apos;s object or class.

2): Synchronized statements are similar to synchronized methods. A synchronized statement can only be executed after a thread has acquired the lock for the object or class referenced in the synchronized statement.
</code></pre><p><strong>Q: When a thread is created and started, what is its initial state? </strong></p>
<pre><code>A: A thread is in the ready state after it has been created and started.
</code></pre><p><strong>Q: What is daemon thread and which method is used to create the daemon thread?</strong></p>
<pre><code>A: Daemon thread is a low priority thread which runs intermittently in the back ground doing the garbage collection operation for the java runtime system.

setDaemon method is used to create a daemon thread.
</code></pre><p><strong>Q: What method must be implemented by all threads? </strong></p>
<pre><code>A: run() method. Whether they
1) extends Thread
2) implements Runnable // this way is preferable. It can extend other class.
</code></pre><h3 id="more-questions">More Questions</h3>
<p><strong>Q: How does Java handle integer overflows and underflows? </strong></p>
<pre><code>A: It uses those low order bytes of the result that can fit into the size of the type allowed by the operation.
</code></pre><p><strong>Q: Does garbage collection guarantee that a program will not run out of memory?</strong></p>
<pre><code>A: No.
1) It is possible for programs to use up memory resources faster than they are garbage collected.
2) It is also possible for programs to create objects that are not subject to garbage collection
</code></pre><p><strong>Q: What is the difference between preemptive scheduling and time slicing? </strong></p>
<pre><code>1) Under preemptive scheduling, the highest priority task executes until it enters the waiting or dead states or a higher priority task comes into existence.

2) Under time slicing, a task executes for a predefined slice of time and then reenters the pool of ready tasks. The scheduler then determines which task should execute next, based on priority and other factors.
</code></pre><p><strong>Q: What is the purpose of finalization? </strong></p>
<pre><code>A: It is to give an unreachable object the opportunity to perform any cleanup processing before the object is garbage collected.
</code></pre><p><strong>Q: What is the difference between processes and threads? </strong></p>
<pre><code>1) A process is an execution of a program
2) A thread is a single execution sequence within the process.
3) A process can contain multiple threads.
4) A thread is sometimes called a lightweight process.
</code></pre><p><strong>Q: Briefly explain high-level thread states? </strong></p>
<pre><code>The state chart diagram below describes the thread states.

1) Runnable &#x2014; A thread becomes runnable when you call the start( ), but does not necessarily start running immediately. It will be pooled waiting for its turn to be picked for execution by the thread scheduler based on thread priorities.

2) Running: The processor is actively executing the thread code. It runs until it becomes blocked, or voluntarily gives up its turn with this static method Thread.yield( ). Because of context switching overhead, yield( ) should not be used very frequently

3) Waiting:
a. setup time is optional.
b. release both execution right and lock
c. Needs notify() to wake up.
A thread is in a blocked state while it waits for some external processing
such as file I/O to finish.A call to currObject.wait( ) method causes the
current thread to wait until some other thread invokescurrObject.notify( )
or the currObject.notifyAll( ) is executed.

4) Sleeping:
a. setup tiem is required.
b. release execution right, but not lock.
Java threads are forcibly put to sleep (suspended) with this overloaded method:
Thread.sleep(milliseconds), Thread.sleep(milliseconds, nanoseconds);

4) Blocked on I/O: Will move to runnable after I/O condition like reading bytes of data etc changes.

5) Blocked on synchronization: will move to running when a lock is acquired.

6) Dead: The thread is finished working.
</code></pre><p><strong>Q. What is the difference between yield and sleeping? </strong></p>
<pre><code>1). When a task invokes yield( ), it changes from running state to runnable state.
**Sleep** causes thread to suspend itself for x milliseconds
**Yield** suspends the thread and immediately moves it to the ready queue (the queue which the CPU uses to run threads).
2) When a task invokes sleep ( ), it changes from running state to waiting/sleeping state.
3) The method wait(1000) causes the current thread to wait up to one second a signal from other threads. A thread could wait less than 1 second if it receives the notify( ) or notifyAll( ) method call.
4) The call to sleep(1000) causes the current thread to sleep for t least 1 second.
</code></pre><h3 id="java-concurrency-interview-questions">Java Concurrency Interview Questions</h3>
<p><strong>Q.What is atomic operation? What are atomic classes in Java Concurrency API? </strong></p>
<pre><code>1) Atomic operations are performed in a single unit of task without interference from other operations.

2) Atomic operations are necessity in multi-threaded environment to avoid data inconsistency.

3) For example int++ is not an atomic operation. So by the time one threads read it&#x2019;s value and increment it by one, other thread has read the older value leading to wrong result.

4) To solve this issue, we will have to make sure that increment operation on count is atomic, we can do that using Synchronization but Java 5 java.util.concurrent.atomic provides wrapper classes for int and long that can be used to achieve this atomically without usage of Synchronization.
</code></pre><p><strong>Q.What is Lock interface in Java Concurrency API? What are it&#x2019;s benefits over synchronization?</strong></p>
<pre><code>1) Lock interface provide more extensive locking operations than can be obtained using synchronized methods and statements.

2) They allow more flexible structuring, may have quite different properties, and may support multiple associated Condition objects.

3) The advantages of a lock are:
**it&#x2019;s possible to make them fair
**it&#x2019;s possible to make a thread responsive to interruption while waiting on a Lock object.
**it&#x2019;s possible to try to acquire the lock, but return immediately or after a timeout if the lock can&#x2019;t be acquired
**it&#x2019;s possible to acquire and release locks in different scopes, and in different orders
</code></pre><p><strong>Q.What is Executors Framework?</strong></p>
<pre><code>1) The Executor framework is a framework for standardizing invocation, scheduling, execution, and control of asynchronous tasks according to a set of execution policies.

2) Creating a lot many threads with no bounds to the maximum threshold can cause application to run out of heap memory. So, creating a ThreadPool is a better solution as a finite number of threads can be pooled and reused.

3) Executors framework facilitate process of creating Thread pools in java.
</code></pre><p><strong>Q.What is BlockingQueue? How can we implement Producer-Consumer problem using Blocking Queue? </strong></p>
<pre><code>1) BlockingQueue is a Queue that supports operations that wait for the queue to become non-empty when retrieving and removing an element, and wait for space to become available in the queue when adding an element.

2) BlockingQueue doesn&#x2019;t accept null values and throw NullPointerException if you try to store null value in the queue.

3) BlockingQueue implementations are thread-safe. All queuing methods are atomic in nature and use internal locks or other forms of concurrency control.

4) BlockingQueue interface is part of java collections framework and it&#x2019;s primarily used for implementing producer consumer problem.
</code></pre><p><strong>Q.What is Callable and Future?</strong></p>
<pre><code>1) Callable interface in concurrency package that is similar to Runnable interface but it can return any Object and able to throw Exception.

2) Callable interface use Generic to define the return type of Object. Executors class provide useful methods to execute Callable in a thread pool.

3) Since callable tasks run in parallel, we have to wait for the returned Object.

4) Callable tasks return java.util.concurrent.Future object. Using Future we can find out the status of the Callable task and get the returned Object.

5) It provides get() method that can wait for the Callable to finish and then return the result.
</code></pre><p><strong>Q.What is FutureTask Class? </strong></p>
<pre><code>1) FutureTask is the base implementation class of Future interface and we can use it with Executors for asynchronous processing.

2) Most of the time we don&#x2019;t need to use FutureTask class but it comes real handy if we want to override some of the methods of Future interface and want to keep most of the base implementation. We can just extend this class and override the methods according to our requirements.
</code></pre><p><strong>Q.What are Concurrent Collection Classes? </strong></p>
<pre><code>1) Java Collection classes are fail-fast which means that if the Collection will be changed while some thread is traversing over it using iterator, the iterator.next() will throw ConcurrentModificationException.

2) Concurrent Collection classes support full concurrency of retrievals and adjustable expected concurrency for updates. Major classes are ConcurrentHashMap, CopyOnWriteArrayList and CopyOnWriteArraySet
</code></pre><p><strong>Q.What is Executors Class? </strong></p>
<pre><code>1) Executors class provide utility methods for Executor, ExecutorService, ScheduledExecutorService, ThreadFactory, and Callable classes.

2) Executors class can be used to easily create Thread Pool in java, also this is the only class supporting execution of Callable implementations.
</code></pre>
                                
                                </section>
                            
                        </div>
                    </div>
                
            </div>

            
                
                <a href="chapter07_io.html" class="navigation navigation-prev " aria-label="Previous page: IO">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="chapter09_jdbc.html" class="navigation navigation-next " aria-label="Next page: JDBC">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Concurrency","level":"2.1.8","depth":2,"next":{"title":"JDBC","level":"2.1.9","depth":2,"path":"java-quick-review/contents/chapter09_jdbc.md","ref":"java-quick-review/contents/chapter09_jdbc.md","articles":[]},"previous":{"title":"IO","level":"2.1.7","depth":2,"path":"java-quick-review/contents/chapter07_io.md","ref":"java-quick-review/contents/chapter07_io.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-lunr","-search","-highlight","-livereload","advanced-emoji@^0.2.1","include-codeblock@^3.0.2","chapter-fold","back-to-top-button"],"root":".","styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"tbfed-pagefooter":{"copyright":"Copyright Â© shubozhang.com 2020","modify_label":"modified_dateï¼","modify_format":"YYYY-MM-DD HH:mm:ss"},"chapter-fold":{},"fontsettings":{"theme":"white","family":"sans","size":2},"favicon":{"shortcut":"favicon.ico","bookmark":"favicon.ico"},"back-to-top-button":{},"advanced-emoji":{"embedEmojis":false},"include-codeblock":{"check":false,"edit":true,"fixlang":false,"lang":"","template":"ace","theme":"chrome","unindent":true},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","author":"Shubo Zhang","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"GitBook","output.name":"site","gitbook":"3.2.3","description":""},"file":{"path":"java-quick-review/contents/chapter08_concurrency.md","mtime":"2020-12-20T20:19:05.675Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2020-12-21T02:50:32.460Z"},"basePath":"../..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../../gitbook/gitbook.js"></script>
    <script src="../../gitbook/theme.js"></script>
    
        
        <script src="../../gitbook/gitbook-plugin-chapter-fold/chapter-fold.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

